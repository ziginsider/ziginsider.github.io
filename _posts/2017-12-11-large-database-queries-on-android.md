---
layout: post
title: Большие запросы к базе данных на Android
date: 2017-12-11 16:28
tags:
- Java
- Android
- Architecture Components
- Translate
- SQLite
- Pagging Library
- CursorAdapter
---
<a href="https://ziginsider.github.io/large-database-queries-on-android/"><img src="{{ site.baseurl }}/images/largedatabase/intro_39.jpg"></a>

:books: *Перевод статьи Chris Craik <a href="https://medium.com/google-developers/large-database-queries-on-android-cb043ae626e8">"Large Database Queries on Android"</a>.*

*Статья упомянута в офф. документации Google в разделе <a href="">Pagging Library</a>. И является вполне программной в смысле видения Google дальнейшего развития работы с SQLite в Android. Это новое видение, вполне не ново, т.к. вопрос (скорость и удобство работы с SQLite, загрузка больших порций данных) стоял давно и те или иные сторонние библиотеки решали этот вопрос. Но представив свою концепцию архитектуры приложений <a href="https://developer.android.com/topic/libraries/architecture/index.html">Android Architecture Components</a> разработчики Android Team не обошли внимание проблемы SQLite. Данная статья обзорная, она говорит о проблемах работы с данными, при использовании SQLite, и описывает пути решения данных проблем.*

<br>
### Возможности
SQLite - отличный способ хранить множество данных на Android, но так сложилось, что загрузка этих наборов данных в UI довольно нетривиальна, и может привести к проблемам производительности. Перед запуском новой библиотеки Paging Library, мы исследовали существующие подходы к подгрузке данных, и особенно потенциальные ловушки, при использовании SQLiteCursor.

В этой статье мы рассмотрим его проблемы, и поймем почему мы заинтересованы в использование небольших запросов с помощью <a href="https://developer.android.com/topic/libraries/architecture/room.html">Room</a> и <a href="https://developer.android.com/topic/libraries/architecture/paging.html">Pagging Library</a> в <a href="https://developer.android.com/topic/libraries/architecture/index.html">Architecture Android Components</a>.

<br>
### SQLiteCursor и CursorAdapter
<a href="https://developer.android.com/reference/android/database/sqlite/SQLiteCursor.html">SQLiteCursor</a> это возвращаемый тип при запросе к базе данных SQLite в Android. Он позволяет получить большой объем данных за фиксированную "стоимость". Первое чтение данных инициализирует <a href="https://developer.android.com/reference/android/database/CursorWindow.html">CursorWindow</a>, буфер строк с дефолтным размером 2MB, который содержит контент из базы данных. SQLiteCursor обновляет этот буфер полностью каждый раз, когда вы делаете запрос на строку, которая еще не представлена в выборке. Таким образом SQLiteCursor реализует подкачку данных с фиксированным размером выборки.   

<a href="https://developer.android.com/reference/android/database/CursorWindow.html">CursorAdapter</a> был доступен начиная с API 1, и предоставил простой способ получения данных из курсора (обычно SQLiteCursor) для элементов ListView. Хотя он отлично справляется с этой функцией, он обращается к базе данных в пользовательском потоке всякий раз, когда требуется загрузка новых данных. Это само по себе не приемлемо для современных и отзывчивых приложений. Тогда мы можем спросить, не может ли у нас быть адаптера, основанного на курсоре, но который бы загружал данные в фоновом потоке? В конце концов у SQLiteCursor есть подкачка данных.

<br>
### Проблемы с подкачкой данных с ипользованием SQLiteCursor

Большинство проблем с подкачкой с использованием SQLiteCursor происходит из-за неожиданного поведения, поскольку он использует свое окно (CursorWindow) для загрузки выборки с данными. Ниже приведен список проблем, с которыми мы столкнулись, когда эксперементировали с (??внутренней??) выборкой SQLiteCursor для <a href="">Paging Library</a>:

<br>
- **SQLiteCursor не поддерживает транзакции базы данных**

 :zap: Когда я начал исследовать подкачку данных, я был не опытен в SQLite и особенно в Cursor в Android. Я просто предположил, что SQLiteCursor, после загрузки окна данных, мог бы приостановить запрос, до того момента, когда ему понадобится следующее окно. Таким образом, доступ к десятому окну будет таким же эффективным, как и к первому. *Но это не так*. Каждый раз, когда читается новое окно, запрос перезапускается с начала и пропускает строки которые не запрашиваются для этого окна. Каждый раз полный проход по данным. Это от того, что *SQLiteCursor не может останавливать и возобновлять запросы*.
 
Это похоже на доступ к элементам с 1000-го по 1500-й в связном списке (LinkedList) - вам нужно проходить большое количество элементов, чтобы загрузить следующую порцию выборки. Когда вы загружаете, каждое последующее окно должно пропускать все больше и больше данных, прежде чем начнет загружать необходимые для него. Это замедляет загрузку. Это эквивалентно использованию ключевого слова SQL `OFFSET` для пропуска данных, которое <a href="http://www.sqlite.org/cvstrac/wiki?p=ScrollingCursor">не является самым эффективным способом заполнения выборки данными</a>, и этого нельзя  избежать, опираясь на подгрузку данных с помощью SQLiteCursor. Вы можете посмотреть как SQLiteCursor подгружает данные в новое окно <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/jni/android_database_SQLiteConnection.cpp#695">здесь</a>.

<br>
- **SQLiteCursor.getCount() обязателен, и проходит по всему запросу**

 :zap: Перед чтением самой первой строки, SQLiteCursor вызыввает `getCount()` для проверки границ. Поскольку *SQLite вынужден сканировать весь результат запроса* для его подсчета (опять же, как в связном списке), это может привести к значительным накладным расходам. Если вы постепенно подгружаете большой запрос в UI, в ответ на прокрутку пользователя, вам может не понадобится знать весь его (запроса) размер, поэтому подсчет добавляет ненужную начальную работу. 

<br>
- **SQLiteCursor.getCount() всегда загружает первое окно данных**

 :zap: Как часть подсчета количества, при сканировании полученной выборки, SQLiteCursor заранее заполняет свое окно с позиции 0, в предположении, что первые элементы в запросе будут нужны.

Он предварительно загружает эти элементы, чтобы он мог знать заранее сколько приблизительно строк попадает в окно (подробнее об этом ниже). Эта рискованная загрузка имеет смысл, если данные предоставляются с начала запроса, но позиция, восстанавливаемая из сохраненного состояния, может быть намного дальше по списку, где начальное окно не релевантно. Если вы хотите предоставить данные из третьего окна, вы вынуждены сначала загрузить и выбросить 2 MB данных первого окна. Код такого поведения смотрите <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/java/android/database/sqlite/SQLiteCursor.java#130">здесь</a>

<br>
- **SQLiteCursor может загружать данные, которые вы не запрашивали**

 :zap: `Cursor.moveToPosition()` гарантирует, что запрашиваемая строка находится в окне, но *SQLiteCursor не начинает наполняться данными, начиная с запрошенной строки*. Поскольку SQLiteCursor не предполагает, что приложение читает наперед, он начинает заполнять окно, когда находится на расстоянии около одной трети (⅓) от целевой позиции. Это означает, что CursorAdapter перескакивает через несколько строк после того, как загрузка окна не вызывает загрузку следующего окна. Это также означает, что каждым 2 MB загруженных данных предшествует загрузка 650 KB или более данных, которые уже были получены. Вы можете посмотреть код и получить объяснения такому поведению <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/java/android/database/DatabaseUtils.java#742">здесь</a> 

<br>
- **Позиция с которой SQLiteCursor начинает загрузку может быть непредсказуема**

 :zap: Когда SQLiteCursor пытается загрузить целевую позицию, он пытается начать загрузку с ⅓ от размера окна от требуемой позиции. Это означает то, что он должен предполагать какое количество строк помещается в окно. Для этого используется число строк первого загруженного окна. К сожалению это означает, что если ваши строки имеют неодинаковый размер (например, если в базе данных хранятся комментарии пользователей в виде String произвольной длины), его предположение может оказаться неверным. *SQLiteCursor может недооценить расстояние до целевой позиции*, заполняя окно данными, и заполнить его еще до достижения требуемой строки, - затем, отменить все, и начать заполнять снова. Если, например, вы двигаетесь через большой запрос и получаете строку, которая требует перезапустить окно, тогда возможно загрузка захватит лишь незначительное число новых строк. Код очищения окна и его перезапуска <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/jni/android_database_SQLiteConnection.cpp#709">здесь</a>.

<br>
- **Курсоры требуют закрытия**

 :zap: Курсор должен быть закрыт с помощью метода `close()`. Поэтому, где бы не хранились курсоры, всегда должен быть метод, который закрывает их, когда они больше не нужны. CursorAdapter оснобенно не помогает в этом, перекладывая ответственность на разработчика. 
Для хранения и переиспользования курсора разработчику приходится писать код для обработки таких событий, как, например, перезапуск Activity.

<br>
- **SQLiteCursor не знает, что данные изменились**

 :zap: *SQLiteCursor не отслеживает, что данные базы данных изменились после того как первое окно прочитано* (и произведен первый подсчет). Это означает, что если некоторые элементы базы были удалены, или новые добавлены, то размер кэша SQLiteCursor будет неверен - проблема как для проверки размеров запроса, так и для того, чтобы в итоге загруженные данные были согласованы. И мы можем получить исключение, если было обращение к строке, которая не существует, или получить непоследовательные данные в некоторых случаях. Например, если вы уже загрузили строку N, а новый элемент вставлен в позицию 0, и затем вы пытаетесь загрузить строку N+1, вы загрузете строку N второй раз.

<br>
### Избегая проблем
Вышеперечисленные проблемы говорят нам, что SQLiteCursor не масштабируется для запросов с тысячами результатов. *К счастью, у всех этих проблем есть одно простейшее решение: небольшие запросы.* Запросы, которые вписываются в один CursorWindow, избегают всех проблем, поэтому мы так тчательно поддерживаем их в Paging и Room. Обычно размер выборки настраивается от десяти до двадцати элементов и запрашивается сразу несколько элементов.

Хотя многое зависит от размеров выборки - более длинные запросы, приближающиеся к размеру окна, увеличивают производительность, но увеличивают время ожидания и использование памяти. Десять элементов в выборке имеет смысл, если у вас длинный список элементов и база данных не является узким местом, а 300 элементов может быть лучше, если список состоит из небольших элементов, или если ваши запросы достаточно дороги.




If you are relying on the internal paging of SQLiteCursor to lazily load a much larger set of results, we recommend that you switch to another approach. Either use the new Paging Library and its integration with the Room Persistence Library, or use a custom implementation where you handle the paging yourself and ensure that your query results are small enough to fit in a single CursorWindow.






[в процессе]

