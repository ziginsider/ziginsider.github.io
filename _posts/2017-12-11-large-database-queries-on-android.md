---
layout: post
title: Большие запросы к базе данных на Android
date: 2017-12-11 16:28
tags:
- Java
- Android
- Architecture Components
- Translate
- SQLite
- Pagging Library
- CursorAdapter
---
<a href="https://ziginsider.github.io/large-database-queries-on-android/"><img src="{{ site.baseurl }}/images/largedatabase/intro_39.jpg"></a>

:books: *Перевод статьи Chris Craik <a href="https://medium.com/google-developers/large-database-queries-on-android-cb043ae626e8">"Large Database Queries on Android"</a>.*

*Статья упомянута в офф. документации Google в разделе <a href="">Pagging Library</a>. И является вполне программной в смысле видения Google дальнейшего развития работы с SQLite в Android. Это новое видение, вполне не ново, т.к. вопрос (скорость и удобство работы с SQLite, загрузка больших порций данных) стоял давно и те или иные сторонние библиотеки решали этот вопрос. Но представив свою концепцию архитектуры приложений <a href="https://developer.android.com/topic/libraries/architecture/index.html">Android Architecture Components</a> разработчики Android Team не обошли внимание проблемы SQLite. Данная статья обзорная, она говорит о проблемах работы с данными, при использовании SQLite, и описывает пути решения данных проблем.*

<br>
### Возможности
SQLite - отличный способ хранить множество данных на Android, но так сложилось, что загрузка этих наборов данных в UI довольно нетривиальна, и может привести к проблемам производительности. Перед запуском новой библиотеки Paging Library, мы исследовали существующие подходы к подгрузке данных, и особенно потенциальные ловушки, при использовании SQLiteCursor.

В этой статье мы рассмотрим его проблемы, и поймем почему мы заинтересованы в использование небольших запросов с помощью <a href="https://developer.android.com/topic/libraries/architecture/room.html">Room</a> и <a href="https://developer.android.com/topic/libraries/architecture/paging.html">Pagging Library</a> в <a href="https://developer.android.com/topic/libraries/architecture/index.html">Architecture Android Components</a>.

<br>
### SQLiteCursor и CursorAdapter
<a href="https://developer.android.com/reference/android/database/sqlite/SQLiteCursor.html">SQLiteCursor</a> это возвращаемый тип при запросе к базе данных SQLite в Android. Он позволяет получить большой объем данных за фиксированную "стоимость". Первое чтение данных инициализирует <a href="https://developer.android.com/reference/android/database/CursorWindow.html">CursorWindow</a>, буфер строк с дефолтным размером 2MB, который содержит контент из базы данных. SQLiteCursor обновляет этот буфер полностью каждый раз, когда вы делаете запрос на строку, которая еще не представлена в выборке. Таким образом SQLiteCursor реализует подкачку данных с фиксированным размером выборки.   

<a href="https://developer.android.com/reference/android/database/CursorWindow.html">CursorAdapter</a> был доступен начиная с API 1, и предоставил простой способ получения данных из курсора (обычно SQLiteCursor) для элементов ListView. Хотя он отлично справляется с этой функцией, он обращается к базе данных в пользовательском потоке всякий раз, когда требуется загрузка новых данных. Это само по себе не приемлемо для современных и отзывчивых приложений. Тогда мы можем спросить, не может ли у нас быть адаптера, основанного на курсоре, но который бы загружал данные в фоновом потоке? В конце концов у SQLiteCursor есть подкачка данных.

<br>
### Проблемы с подкачкой данных с ипользованием SQLiteCursor

Большинство проблем с подкачкой с использованием SQLiteCursor происходит из-за неожиданного поведения, поскольку он использует свое окно (CursorWindow) для загрузки выборки с данными. Ниже приведен список проблем, с которыми мы столкнулись, когда эксперементировали с (??внутренней??) выборкой SQLiteCursor для <a href="">Paging Library</a>:

- **SQLiteCursor не поддерживает транзакции базы данных**

:zap: Когда я начал исследовать подкачку данных, я был не опытен в SQLite и особенно в Cursor в Android. Я просто предположил, что SQLiteCursor, после загрузки окна данных, мог бы приостановить запрос, до того момента, когда ему понадобится следующее окно. Таким образом, доступ к десятому окну будет таким же эффективным, как и к первому. *Но это не так*. Каждый раз, когда читается новое окно, запрос перезапускается с начала и пропускает строки которые не запрашиваются для этого окна. Каждый раз полный проход по данным. Это от того, что *SQLiteCursor не может останавливать и возобновлять запросы*.
 
Это похоже на доступ к элементам с 1000-го по 1500-й в связном списке (LinkedList) - вам нужно проходить большое количество элементов, чтобы загрузить следующую порцию выборки. Когда вы загружаете, каждое последующее окно должно пропускать все больше и больше данных, прежде чем начнет загружать необходимые для него. Это замедляет загрузку. Это эквивалентно использованию ключевого слова SQL `OFFSET` для пропуска данных, которое <a href="http://www.sqlite.org/cvstrac/wiki?p=ScrollingCursor">не является самым эффективным способом заполнения выборки данными</a>, и этого нельзя  избежать, опираясь на подгрузку данных с помощью SQLiteCursor. Вы можете посмотреть как SQLiteCursor подгружает данные в новое окно <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/jni/android_database_SQLiteConnection.cpp#695">здесь</a>.

- **SQLiteCursor.getCount() обязателен, и проходит по всему запросу**

:zap: Перед чтением самой первой строки, SQLiteCursor вызыввает `getCount()` для проверки границ. Поскольку *SQLite вынужден сканировать весь результат запроса* для его подсчета (опять же, как в связном списке), это может привести к значительным накладным расходам. Если вы постепенно подгружаете большой запрос в UI, в ответ на прокрутку пользователя, вам может не понадобится знать весь его (запроса) размер, поэтому подсчет добавляет ненужную начальную работу. 

- **SQLiteCursor.getCount() всегда загружает первое окно данных**

:zap: Как часть подсчета количества, при сканировании полученной выборки, SQLiteCursor заранее заполняет свое окно с позиции 0, в предположении, что первые элементы в запросе будут нужны.

Он предварительно загружает эти элементы, чтобы он мог знать заранее сколько приблизительно строк попадает в окно (подробнее об этом ниже). Эта рискованная загрузка имеет смысл, если данные предоставляются с начала запроса, но позиция, восстанавливаемая из сохраненного состояния, может быть намного дальше по списку, где начальное окно не релевантно. Если вы хотите предоставить данные из третьего окна, вы вынуждены сначала загрузить и выбросить 2 MB данных первого окна. Код такого поведения смотрите <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/java/android/database/sqlite/SQLiteCursor.java#130">здесь</a>

- **SQLiteCursor может загружать данные, которые вы не запрашивали**

:zap: `Cursor.moveToPosition()` гарантирует, что запрашиваемая строка находится в окне, но *SQLiteCursor не начинает наполняться данными, начиная с запрошенной строки*. Поскольку SQLiteCursor не предполагает, что приложение читает наперед, он начинает заполнять окно, когда находится на расстоянии около одной трети (⅓) от целевой позиции. Это означает, что CursorAdapter перескакивает через несколько строк после того, как загрузка окна не вызывает загрузку следующего окна. Это также означает, что каждым 2 MB загруженных данных предшествует загрузка 650 KB или более данных, которые уже были получены. Вы можете посмотреть код и получить объяснения такому поведению <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/java/android/database/DatabaseUtils.java#742">здесь</a> 

- **Позиция с которой SQLiteCursor начинает загрузку может быть непредсказуема**

:zap: Когда SQLiteCursor пытается загрузить целевую позицию, он пытается начать загрузку с ⅓ от размера окна от требуемой позиции. Это означает то, что он должен предполагать какое количество строк помещается в окно. Для этого используется число строк первого загруженного окна. К сожалению это означает, что если ваши строки имеют неодинаковый размер (например, если в базе данных хранятся комментарии пользователей в виде String произвольной длины), его предположение может оказаться неверным. *SQLiteCursor может недооценить расстояние до целевой позиции*, заполняя окно данными, и заполнить его еще до достижения требуемой строки, - затем, отменить все, и начать заполнять снова. Если, например, вы двигаетесь через большой запрос и получаете строку, которая требует перезапустить окно, тогда возможно загрузка захватит лишь незначительное число новых строк. Код очищения окна и его перезапуска <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/jni/android_database_SQLiteConnection.cpp#709">здесь</a>.

- **Курсоры требуют закрытия**

:zap: Курсор должен быть закрыт с помощью метода `close()`. Поэтому, где бы не хранились курсоры, всегда должен быть метод, который закрывает их, когда они больше не нужны. CursorAdapter оснобенно не помогает в этом, перекладывая ответственность на разработчика. 
Для хранения и переиспользования курсора разработчику приходится писать код для обработки таких событий, как, например, перезапуск Activity.

- **SQLiteCursor не знает, что данные изменились**

:zap:

SQLiteCursor does not know data has changed
SQLiteCursor doesn’t track if the database has changed after the first window read (and first count). This means that if some items are added or removed, the SQLiteCursor’s cached size is incorrect — a problem both for bounds checking and if you want your loaded data to look consistent. This can cause an exception when moving to a row that no longer exists, or inconsistent data in some circumstances. For example, if you’ve loaded row N already and a new item is inserted at position 0, and you then try to read row N+1, you’ll end up loading the old row N a second time.



[в процессе]

