---
layout: post
title: Большие запросы к базе данных на Android
date: 2017-12-11 16:28
tags:
- Java
- Android
- Architecture Components
- Translate
- SQLite
- Pagging Library
- CursorAdapter
---
<a href="https://ziginsider.github.io/large-database-queries-on-android/"><img src="{{ site.baseurl }}/images/largedatabase/intro_39.jpg"></a>

:books: *Перевод статьи Chris Craik <a href="https://medium.com/google-developers/large-database-queries-on-android-cb043ae626e8">"Large Database Queries on Android"</a>.*

*Статья упомянута в офф. документации Google в разделе <a href="">Pagging Library</a>. И является вполне программной в смысле видения Google дальнейшего развития работы с SQLite в Android. Это новое видение, вполне не ново, т.к. вопрос (скорость и удобство работы с SQLite, загрузка больших порций данных) стоял давно и те или иные сторонние библиотеки решали этот вопрос. Но представив свою концепцию архитектуры приложений <a href="https://developer.android.com/topic/libraries/architecture/index.html">Android Architecture Components</a> разработчики Android Team не обошли внимание проблемы SQLite. Данная статья обзорная, она говорит о проблемах работы с данными, при использовании SQLite, и описывает пути решения данных проблем.*

<br>
### Возможности
SQLite - отличный способ хранить множество данных на Android, но так сложилось, что загрузка этих наборов данных в UI довольно нетривиальна, и может привести к проблемам производительности. Перед запуском новой библиотеки Paging Library, мы исследовали существующие подходы к подгрузке данных, и особенно потенциальные ловушки, при использовании SQLiteCursor.

В этой статье мы рассмотрим его проблемы, и поймем почему мы заинтересованы в использование небольших запросов с помощью <a href="https://developer.android.com/topic/libraries/architecture/room.html">Room</a> и <a href="https://developer.android.com/topic/libraries/architecture/paging.html">Pagging Library</a> в <a href="https://developer.android.com/topic/libraries/architecture/index.html">Architecture Android Components</a>.

<br>
### SQLiteCursor и CursorAdapter
<a href="https://developer.android.com/reference/android/database/sqlite/SQLiteCursor.html">SQLiteCursor</a> это возвращаемый тип при запросе к базе данных SQLite в Android. Он позволяет получить большой объем данных за фиксированную "стоимость". Первое чтение данных инициализирует <a href="https://developer.android.com/reference/android/database/CursorWindow.html">CursorWindow</a>, буфер строк с дефолтным размером 2MB, который содержит контент из базы данных. SQLiteCursor обновляет этот буфер полностью каждый раз, когда вы делаете запрос на строку, которая еще не представлена в выборке. Таким образом SQLiteCursor реализует постраничную загрузку данных с фиксированным размером страницы.

<a href="https://developer.android.com/reference/android/database/CursorWindow.html">CursorAdapter</a> был доступен начиная с API 1, и предоставил простой способ получения данных из курсора (обычно SQLiteCursor) для элементов ListView. Хотя он отлично справляется с этой функцией, он обращается к базе данных в пользовательском потоке всякий раз, когда требуется загрузка новых данных. Это само по себе не приемлемо для современных и отзывчивых приложений. Тогда мы можем спросить, не может ли у нас быть адаптера, основанного на курсоре, но который бы загружал данные в фоновом потоке? В конце концов у SQLiteCursor есть постраничная загрузка данных.

<br>
### Проблемы с постраничной загрузкой данных с ипользованием SQLiteCursor

Большинство проблем с постраничной загрузкой с использованием SQLiteCursor происходит из-за поведения, которое нельзя предсказать, поскольку он использует свое окно (CursorWindow) для постраничных данных. Ниже приведен список проблем, с которыми мы столкнулись, когда эксперементировали с внутренней постраничной загрузкой через SQLiteCursor, что привело нас к созданию <a href="">Paging Library</a>:

<br>
- **SQLiteCursor не поддерживает транзакции базы данных**

&#032;&#032;:zap: Когда я начал исследовать постраничную загрузку данных, я был не опытен в SQLite и особенно в Cursor в Android. Я просто предположил, что SQLiteCursor, после загрузки окна данных, мог бы приостановить запрос, до того момента, когда ему понадобится следующее окно. Таким образом, доступ к десятому окну будет таким же эффективным, как и к первому. *Но это не так*. Каждый раз, когда читается новое окно, запрос перезапускается с начала и пропускает строки которые не запрашиваются для этого окна. Каждый раз полный проход по данным. Это от того, что *SQLiteCursor не может останавливать и возобновлять запросы*.
 
Это похоже на доступ к элементам с 1000-го по 1500-й в связном списке (LinkedList) - вам нужно проходить большое количество элементов, чтобы загрузить следующую страницу данных. Когда вы загружаете, каждое последующее окно должно пропускать все больше и больше данных, прежде чем начнет загружать необходимые для него. Это замедляет загрузку. Это эквивалентно использованию ключевого слова SQL `OFFSET` для пропуска данных, которое <a href="http://www.sqlite.org/cvstrac/wiki?p=ScrollingCursor">не является самым эффективным способом заполнения выборки данными</a>, и этого нельзя  избежать, опираясь на постраничную загрузку данных с помощью SQLiteCursor. Вы можете посмотреть как SQLiteCursor подгружает данные в новое окно <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/jni/android_database_SQLiteConnection.cpp#695">здесь</a>.

<br>
- **SQLiteCursor.getCount() обязателен, и проходит по всему запросу**

&#032;&#032;:zap: Перед чтением самой первой строки, SQLiteCursor вызыввает `getCount()` для проверки границ. Поскольку *SQLite вынужден сканировать весь результат запроса* для его подсчета (опять же, как в связном списке), это может привести к значительным накладным расходам. Если вы постепенно подгружаете большой запрос в UI, в ответ на прокрутку пользователя, вам может не понадобится знать весь его (запроса) размер, поэтому подсчет добавляет ненужную начальную работу. 

<br>
- **SQLiteCursor.getCount() всегда загружает первое окно данных**

&#032;&#032;:zap: Как часть подсчета количества, при сканировании полученной выборки, SQLiteCursor заранее заполняет свое окно с позиции 0, в предположении, что первые элементы в запросе будут нужны.

Он предварительно загружает эти элементы, чтобы он мог знать заранее сколько приблизительно строк попадает в окно (подробнее об этом ниже). Эта рискованная загрузка имеет смысл, если данные предоставляются с начала запроса, но позиция, восстанавливаемая из сохраненного состояния, может быть намного дальше по списку, где начальное окно не релевантно. Если вы хотите предоставить данные из третьего окна, вы вынуждены сначала загрузить и выбросить 2 MB данных первого окна. Код такого поведения смотрите <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/java/android/database/sqlite/SQLiteCursor.java#130">здесь</a>

<br>
- **SQLiteCursor может загружать данные, которые вы не запрашивали**

&#032;&#032;:zap: `Cursor.moveToPosition()` гарантирует, что запрашиваемая строка находится в окне, но *SQLiteCursor не начинает наполняться данными, начиная с запрошенной строки*. Поскольку SQLiteCursor не предполагает, что приложение читает наперед, он начинает заполнять окно, когда находится на расстоянии около одной трети (⅓) от целевой позиции. Это означает, что CursorAdapter перескакивает через несколько строк после того, как загрузка окна не вызывает загрузку следующего окна. Это также означает, что каждым 2 MB загруженных данных предшествует загрузка 650 KB или более данных, которые уже были получены. Вы можете посмотреть код и получить объяснения такому поведению <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/java/android/database/DatabaseUtils.java#742">здесь</a> 

<br>
- **Позиция с которой SQLiteCursor начинает загрузку может быть непредсказуема**

&#032;&#032;:zap: Когда SQLiteCursor пытается загрузить целевую позицию, он пытается начать загрузку с ⅓ от размера окна от требуемой позиции. Это означает то, что он должен предполагать какое количество строк помещается в окно. Для этого используется число строк первого загруженного окна. К сожалению это означает, что если ваши строки имеют неодинаковый размер (например, если в базе данных хранятся комментарии пользователей в виде String произвольной длины), его предположение может оказаться неверным. *SQLiteCursor может недооценить расстояние до целевой позиции*, заполняя окно данными, и заполнить его еще до достижения требуемой строки, - затем, отменить все, и начать заполнять снова. Если, например, вы двигаетесь через большой запрос и получаете строку, которая требует перезапустить окно, тогда возможно загрузка захватит лишь незначительное число новых строк. Код очищения окна и его перезапуска <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/jni/android_database_SQLiteConnection.cpp#709">здесь</a>.

<br>
- **Курсоры требуют закрытия**

&#032;&#032;:zap: Курсор должен быть закрыт с помощью метода `close()`. Поэтому, где бы не хранились курсоры, всегда должен быть метод, который закрывает их, когда они больше не нужны. CursorAdapter оснобенно не помогает в этом, перекладывая ответственность на разработчика. Для хранения и переиспользования курсора разработчику приходится писать код для обработки таких событий, как, например, перезапуск Activity.

<br>
- **SQLiteCursor не знает, что данные изменились**

&#032;&#032;:zap: *SQLiteCursor не отслеживает, что данные базы данных изменились после того как первое окно прочитано* (и произведен первый подсчет). Это означает, что если некоторые элементы базы были удалены, или новые добавлены, то размер кэша SQLiteCursor будет неверен - проблема как для проверки размеров запроса, так и для того, чтобы в итоге загруженные данные были согласованы. И мы можем получить исключение, если было обращение к строке, которая не существует, или получить непоследовательные данные в некоторых случаях. Например, если вы уже загрузили строку N, а новый элемент вставлен в позицию 0, и затем вы пытаетесь загрузить строку N+1, вы загрузете строку N второй раз.

<br>
### Избегая проблем
Вышеперечисленные проблемы говорят нам, что SQLiteCursor не масштабируется для запросов с тысячами результатов. *К счастью, у всех этих проблем есть одно простейшее решение: небольшие запросы.* Запросы, которые вписываются в один CursorWindow, избегают всех проблем, поэтому мы так тщательно поддерживаем их в Paging Library и Room. Обычно размер страницы настраивается от десяти до двадцати элементов и запрашивается сразу несколько элементов.

От размеров страницы зависит многое - более длинные запросы, приближающиеся к размеру окна, увеличивают производительность, но возрастает время ожидания и использование памяти. Десять элементов в выборке имеет смысл, если у вас длинный список элементов и база данных не является узким местом, а 300 элементов может быть лучше, если список состоит из небольших элементов, или если ваши запросы достаточно дороги.

Если вы полагаетесь на внутреннюю постраничную загрузку через SQLiteCursor и ленивую загрузку гораздо больших наборов результатов, мы рекомендуем вам использовать другой подход. Тогда используйте <a href="https://developer.android.com/topic/libraries/architecture/paging.html">Paging Library</a> совместно с <a href="https://developer.android.com/topic/libraries/architecture/room.html">Room Persistence Library</a>, или используйте кастомную реализацию, где вы самостоятельно организуете постраничную загрузку. Но тогда следите за тем, чтобы результаты ваших запросов были достаточно малы, чтобы вписаться в CursorWindow. 

Чтобы организовать постраничную загрузку большого SQL-запроса небольшими запросами в Room вы можете использовать новую Paging Library. Вам надо изменить:

{% highlight java %}
@Dao
interface UserDao {
    // обычный запрос списка — падает, если результат очень большой
    @Query(“SELECT * FROM user ORDER BY mAge DESC”)
    LiveData<List<User>> loadUsersByAgeDesc();
}
{% endhighlight %}

на

{% highlight java %}
@Dao
interface UserDao {
    // запрос с постраничной загрузкой — обрабатывает большие запросы
    @Query(“SELECT * FROM user ORDER BY mAge DESC”)
    LivePagedListProvider<Integer, User> loadUsersByAgeDesc();
}
{% endhighlight %}

Затем предоставляются параметры постраничной загрузки, чтобы получить `LiveData<PagedList>`, который содержит результаты больших выборок:

{% highlight java %}
LiveData<PagedList<User>> users = userDao.usersByLastName()
        .create(/*начальная позиция загрузки*/ 0, /*размер выборки*/ 20);
{% endhighlight %}

В приведенном выше коде, мы использовали <a href="https://developer.android.com/topic/libraries/architecture/livedata.html">LiveData</a>-версию результатов запросов с постраничной загрузкой, которая также будет обновлять любые <a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html">Observers</a> (наблюдатели), подписанные на нее, когда меняются данные в базе данных. Чтобы узнать больше о постраничной загрузке из SQLite с использованием architecture components, см. обзор <a href="https://developer.android.com/topic/libraries/architecture/paging.html">Paging Library</a> и <a href="https://github.com/googlesamples/android-architecture-components/tree/master/PagingSample">пример её использования</a> на GitHub.

<br>
### Android Platform
We’re currently looking at improving some of the behaviors of SQLiteCursor in a future Android release. For example, perhaps both the CursorWindow size, as well as the ⅓ of a window heuristic should both be configurable, since modern usage patterns look very different than when SQLiteCursor and CursorAdapter were designed. When we do make changes, we’ll be sure to update the Room Persistence Library to use these new options to keep queries as efficient as possible.

:fist:
[в процессе]

